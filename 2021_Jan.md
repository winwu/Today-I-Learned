Author: winwu

## 2020-01-29

### [讀書筆記]

閱讀書籍為: [TypeScript 程式設計](http://books.gotop.com.tw/o_A604) - 原著: Boris Cherny - chapter 3 and chapter 4


* 使用 let 或 const 定義變數會影響 TypeScript 如何推論型別。

#### 呼叫 function 的幾種方式

```ts
// 例:
function mul(n1: number; n2: number): number {
    return n1*n2;
}
```

1. mul(5, 2)
2. mul.apply(null, [5, 2])
3. mul.call(null, 5, 2)
4. mul.bind(null, 5, 2)()


* apply 跟 call 的用法差異是一個是帶 array，另一個則是把所有的參數依序帶入。
* bind 不會馬上執行 function 而是回來一個新的 function，所以要調用的話就需要再一個 ()。


#### Rest Parameters

JS 的 arguments 物件較沒有型別安全性 (e.g 例如直接 loop arguments 時，ts 僅能推斷其型別為 any)，此時可使用 rest parameters，可以安全的接受任意長度的 array 參數。



#### Generic

* 宣告泛型的位置會決定該型別的範疇，也會決定 ts 甚麼時候把一個具體的型別繫結到泛型上。

兩種方式:

```ts
// 1. 實際呼叫 FooGeneric 時將具體型別繫結到 T
type FooGeneric = {
    <T>(array: T[], f: (item: T) => boolean) : T[]
}
```

```ts
// 2. 要求使用 BarGeneric 時要明確的繫結一個型別
type BarGeneric<T> = {
    (array: T[], f: (item: T) => boolean) : T[]
}
```

* 泛型也可以有預設值:

```ts
type someEvent<T = HTMLElement> = {
    target: T,
    type: string
}
```




