Author: winwu

## 2020-02-01 ~ 2020-02-02

### [讀書筆記]

接續上週進度。
閱讀書籍為: [TypeScript 程式設計](http://books.gotop.com.tw/o_A604) - 原著: Boris Cherny - chapter 5 & chapter 6

* 註: (1) 以下 ts 即代表 TypeScript (2) 所有的範例程式碼未必是跟書上一模一樣，有些時候我會稍作轉換


#### 關於 mixin

* 一個 class 只能繼承自一個父類別，但是想要達到繼承自多個以上的類別?
* mixin 主要功能是實作多重設計，主要用途來描述一個物件的特質"有"甚麼，而不是"是"甚麼，因此，mixin 要達到的是一個 has-a 而不是 is-a 的關係。
* ts 沒有實作 mixin，所以要自己實作。

#### final
* final 關鍵字在物件導向的語言中有以下的特性 (以 Java 語言為例): 不可被繼承, 不能覆寫 (nonoverridable) 已經 final 方法, 被 final 的屬性值不可以被修改...。
* 雖然 TypeScript 不支援 final 關鍵字，但是可以透過將 constructor 設為 private 來模擬 final 的功用。
* 想要實體化一個 class 但是又不希望該 class 具有被擴充的可能，可以怎麼做?
    * 將 constructor 私有化 + 開出一個 static method 並且實體化自己
    * 例如: (P.S 這邊的範例我有稍微轉換過，不是書上的)

        ```ts
        class AuditLog {
            // 將 constructor 私有化
            private constructor(private content: string) { }

            // 建立一個 static method 可從外部直接呼叫並透過這個 static method 進行實體化
            static add(content: string) {
                return new AuditLog(blablabla...)
            }
        }

        // 用法
        AuditLog.add("something doesn't exists")
        ```

*  [https://github.com/bcherny/programming-typescript-answers/blob/master/src/ch05/exercises.ts](https://github.com/bcherny/programming-typescript-answers/blob/master/src/ch05/exercises.ts)


#### 進階物件型別

* key in 在物件找一個值定義成新的 type。要注意只能使用方括號 [] 來查找物件屬性。


* 伴隨物件模式: 同樣的名子用來宣告型別跟物件。
* Without, Exclude: 取得屬於 T 但不屬於 U 的型別。
* NonNullable: 排除 null 跟 undefined 之後的型別。
* ReturnType: 聲明型別回傳的 type
* 型別斷言有兩種方式:

    ```ts
    // 1
    someFun(aa as string)

    // 2
    someFun(<string>aa)
    ```

    建議使用第 1 種，因為第二種可能會跟 tsx 的語法有所衝突。

* 確切指定斷言 (define assignment checks): 在某個變數還沒有被指定值之前，但是可以確定程式的邏輯走到那一行的時候是有值的，為了避免 ts 因靜態偵測的關係不知道該值已經被 assign 成符合型別的內容時，就可以使用確切指定斷言。[參考](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#definite-assignment-assertions)

    ```ts
    // let chartWidgetList: string; <- 無確切指定斷言
    let chartWidgetList!: string;

    function getChartList();
    chartWidgetList.split(',');

    function getChartList() {
        chartWidgetList = 'browser, events, locations';
    }

    ```

* 型別烙印可以協助更精確的定義型別，較適用於需要型別安全性高的大型系統。

